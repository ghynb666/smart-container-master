# 优惠券秒杀功能设计方案

## 1. 系统架构设计

### 1.1 总体架构
- **前端层**：用户通过H5或APP访问优惠券秒杀页面，包含滑块验证等安全机制
- **API网关层**：负责请求路由、限流、熔断等
- **应用层**：
  - container-manager：优惠券配置管理
  - container-order：订单管理（新增优惠券秒杀逻辑）
- **中间件层**：
  - Redis：缓存优惠券库存、用户秒杀记录
  - RocketMQ：异步处理优惠券发放
- **数据层**：MySQL数据库存储优惠券相关数据

### 1.2 模块职责
- **秒杀接口模块**：处理用户秒杀请求，包括库存检查、用户验证
- **Redis缓存模块**：管理优惠券库存、秒杀记录等缓存数据
- **消息队列模块**：异步处理优惠券发放，解耦秒杀流程
- **数据库模块**：持久化优惠券数据和用户领取记录

## 2. 核心业务流程

### 2.1 优惠券初始化流程
1. 管理员通过container-manager后台添加优惠券配置
2. 系统将优惠券信息同步到Redis，包括：
   - 优惠券基本信息（HASH结构）
   - 优惠券库存（STRING结构，使用DECRBY操作）
   - 秒杀开始/结束时间（用于验证秒杀有效性）

### 2.2 秒杀请求处理流程
1. **前端验证**：用户完成滑块验证，获取临时令牌
2. **请求拦截**：API网关进行限流和基本验证
3. **库存预减**：使用Redis DECRBY命令扣减库存，若返回值>=0则继续，否则返回秒杀失败
4. **用户限单**：检查用户是否已秒杀过该优惠券（使用Redis SET集合）
5. **发送消息**：生成秒杀订单，发送到RocketMQ
6. **异步处理**：消费者监听消息，完成优惠券发放和数据库更新
7. **结果返回**：立即返回秒杀结果给用户，后续通过消息通知最终状态

### 2.3 异步处理流程
1. 消费者接收秒杀消息
2. 验证消息有效性（防止重复消费）
3. 生成用户优惠券记录
4. 更新优惠券发放数量
5. 发送秒杀成功通知
6. 记录日志

## 3. 数据模型设计

### 3.1 现有表结构优化
- **coupon_config**：新增秒杀相关字段
  - `is_seckill`：是否为秒杀券（0:否 1:是）
  - `seckill_start_time`：秒杀开始时间
  - `seckill_end_time`：秒杀结束时间

### 3.2 Redis数据结构设计
- **优惠券库存**：`SECKILL_COUPON_STOCK:{couponConfigId}`（STRING）
- **用户秒杀记录**：`SECKILL_COUPON_USER:{couponConfigId}`（SET，存储userId）
- **秒杀订单消息**：`SECKILL_ORDER_QUEUE`（LIST，用于临时存储秒杀请求）
- **优惠券基本信息**：`SECKILL_COUPON_INFO:{couponConfigId}`（HASH）

## 4. 关键技术选型

| 技术 | 用途 | 版本 |
|------|------|------|
| Redis | 库存缓存、秒杀记录、分布式锁 | 6.0+ |
| RocketMQ | 异步处理优惠券发放 | 4.9+ |
| Spring Boot | 应用框架 | 2.7+ |
| MySQL | 数据持久化 | 8.0+ |
| Hutool | 工具类库 | 5.8+ |

## 5. 高并发处理策略

### 5.1 限流策略
- **API网关限流**：基于IP或用户ID的限流
- **Redis限流**：使用Redis实现令牌桶算法
- **本地限流**：结合Guava RateLimiter实现单机限流

### 5.2 缓存优化
- **热点数据预热**：秒杀开始前将优惠券信息加载到Redis
- **缓存穿透防护**：使用布隆过滤器或空值缓存
- **缓存击穿防护**：使用Redis分布式锁
- **缓存雪崩防护**：设置不同的过期时间

### 5.3 异步处理
- 使用RocketMQ异步处理优惠券发放，降低系统峰值压力
- 消息队列削峰填谷，提高系统吞吐量

## 6. 防超卖机制

### 6.1 库存预减
- 使用Redis DECRBY原子操作预减库存，确保库存不会超卖
- 库存不足时直接返回秒杀失败

### 6.2 分布式锁
- 秒杀请求处理时使用分布式锁，防止并发问题
- 使用Redis SETNX命令实现分布式锁

### 6.3 数据库层面防护
- 优惠券发放数量更新时使用乐观锁（version字段）
- 数据库唯一约束，确保用户只能领取一次

### 6.4 重复消费防护
- 消息消费时使用幂等性设计，防止重复发放优惠券
- 使用Redis记录已消费的消息ID

## 7. 安全性设计

### 7.1 前端安全
- **滑块验证**：防止恶意脚本批量请求
- **请求频率限制**：限制单个用户的请求频率
- **隐藏秒杀接口**：动态生成秒杀接口地址

### 7.2 后端安全
- **参数校验**：严格校验请求参数
- **签名验证**：防止请求被篡改
- **防刷机制**：基于IP、用户ID的请求频率限制
- **黑名单机制**：对恶意用户进行封禁

### 7.3 数据安全
- 敏感数据加密存储
- 数据库访问权限控制
- 定期数据备份

## 8. 性能优化方案

### 8.1 代码层面优化
- 使用异步编程模型，提高并发处理能力
- 减少数据库查询，尽量使用缓存
- 合理使用线程池，控制并发数

### 8.2 数据库优化
- 索引优化，针对高频查询字段建立索引
- 分库分表，应对大量秒杀数据
- 读写分离，提高查询性能

### 8.3 中间件优化
- Redis集群部署，提高缓存可用性
- RocketMQ集群部署，提高消息处理能力
- 合理设置消息队列分区，提高并发消费能力

## 9. 实现步骤

### 9.1 阶段一：基础准备
1. 扩展coupon_config表，添加秒杀相关字段
2. 在RedisConstants中添加秒杀相关常量
3. 开发滑块验证前端组件

### 9.2 阶段二：核心功能实现
1. 开发优惠券秒杀接口
2. 实现Redis库存预减逻辑
3. 实现用户限单逻辑
4. 开发RocketMQ消息生产者和消费者

### 9.3 阶段三：安全与优化
1. 添加限流、熔断机制
2. 实现防超卖、防刷机制
3. 性能测试与优化

### 9.4 阶段四：测试与上线
1. 单元测试、集成测试
2. 压力测试、性能测试
3. 灰度发布、全量上线

## 10. 监控与运维

### 10.1 监控指标
- 秒杀请求量、成功率
- Redis缓存命中率
- 消息队列堆积情况
- 系统响应时间
- 数据库连接数

### 10.2 告警机制
- 秒杀失败率异常告警
- 消息队列堆积告警
- Redis连接异常告警
- 系统负载过高告警

### 10.3 运维方案
- 定期清理Redis过期数据
- 监控RocketMQ消息消费情况
- 数据库定期备份
- 应急预案制定

## 11. 预期效果

- 支持每秒1000+并发秒杀请求
- 秒杀成功率达到99.9%
- 系统响应时间<500ms
- 有效防止超卖、刷单等问题
- 具备良好的可扩展性和可维护性

该设计方案基于项目现有技术栈，充分利用了Redis和RocketMQ的优势，能够有效应对高并发场景下的优惠券秒杀需求，同时具备良好的安全性和可扩展性。