# 智能货柜项目硬件与软件通信方式开发计划

## 1. 两种通信方式的技术架构设计

### 1.1 基于Netty实现的自定义TCP长连接协议

#### 1.1.1 协议格式定义
| 字段 | 长度(字节) | 类型 | 描述 |
|------|------------|------|------|
| 起始标志 | 2 | 固定值 | 0x5A5A，表示帧起始 |
| 版本号 | 1 | 字节 | 协议版本，初始为0x01 |
| 设备类型 | 1 | 字节 | 0x01-科耐设备，0x02-一诺设备 |
| 设备SN | 16 | ASCII | 设备唯一标识 |
| 命令ID | 2 | 字节 | 命令类型，如心跳、开柜、关柜等 |
| 数据长度 | 2 | 字节 | 后续数据区的长度 |
| 数据区 | N | 字节数组 | 命令相关的数据内容 |
| 校验和 | 2 | 字节 | CRC16校验，覆盖从起始标志到数据区的所有字节 |
| 结束标志 | 2 | 固定值 | 0xAA55，表示帧结束 |

#### 1.1.2 连接建立与维护机制
- **连接建立**：设备主动发起TCP连接，服务端验证设备SN合法性后建立连接
- **连接维护**：
  - 心跳机制：设备每60秒发送一次心跳包，服务端180秒未收到心跳则断开连接
  - 断线重连：设备检测到连接断开后，立即重试连接，重试间隔指数增长（1s→2s→4s→8s，最大64s）
  - 连接映射：Redis中维护设备SN到TCP连接的映射关系，便于服务端主动向设备发送命令

#### 1.1.3 消息编码/解码方式
- **编码器**：
  ```java
  // LengthFieldPrepender：在消息前添加长度字段
  // 自定义协议编码器：将业务对象转换为字节数组，添加协议头和尾
  socketChannel.pipeline().addLast(new LengthFieldPrepender(2));
  socketChannel.pipeline().addLast(new CustomProtocolEncoder());
  ```

- **解码器**：
  ```java
  // LengthFieldBasedFrameDecoder：基于长度字段的帧解码器
  // 自定义协议解码器：将字节数组转换为业务对象
  socketChannel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 2, 2, -4, 0));
  socketChannel.pipeline().addLast(new CustomProtocolDecoder());
  ```

#### 1.1.4 心跳检测机制
- **IdleStateHandler配置**：服务端配置180秒读空闲检测
- **心跳包格式**：命令ID=0x00，数据区为空
- **心跳处理逻辑**：
  - 设备：定时发送心跳包，收到服务端响应后重置定时器
  - 服务端：收到心跳包后回复ACK，180秒未收到心跳则触发IdleStateEvent，断开连接

#### 1.1.5 异常处理流程
- **连接异常**：捕获ConnectException，触发重连机制
- **通信异常**：
  - 数据校验失败：丢弃数据包，记录日志
  - 命令格式错误：返回错误响应，错误码0x01
  - 设备不在线：返回错误响应，错误码0x02
- **业务异常**：根据具体业务逻辑返回相应错误码，如0x03-开柜失败，0x04-库存不足等

### 1.2 MQTT物联网通信协议

#### 1.2.1 MQTT Broker的选型或搭建方案
- **选型**：采用EMQ X开源MQTT Broker，支持高并发连接，提供完整的监控和管理功能
- **部署方式**：
  - 开发环境：Docker容器化部署，单节点
  - 生产环境：集群部署，3节点，支持负载均衡和故障转移
- **配置优化**：
  - 最大连接数：调整为100000
  - 消息留存：默认关闭，根据业务需求选择性开启
  - QoS 2消息存储：使用Redis存储，提高性能

#### 1.2.2 主题（Topic）设计
| 主题格式 | 类型 | 描述 |
|----------|------|------|
| device/up/{设备SN} | 发布 | 设备上报数据到服务端 |
| device/down/{设备SN} | 订阅 | 服务端向设备下发命令 |
| server/up/{通信服务IP} | 订阅 | 设备向指定通信服务上报数据 |
| system/heartbeat | 发布/订阅 | 系统心跳消息 |
| system/alarm | 发布/订阅 | 系统告警消息 |

#### 1.2.3 QoS级别选择
| 业务场景 | QoS级别 | 理由 |
|----------|---------|------|
| 心跳消息 | QoS 0 | 允许丢失，频率高，开销小 |
| 开柜命令 | QoS 2 | 确保只执行一次，避免重复开柜 |
| 设备状态上报 | QoS 1 | 确保至少收到一次，允许重复 |
| 告警信息 | QoS 2 | 确保告警不丢失，且只处理一次 |

#### 1.2.4 消息发布/订阅流程
1. **设备上线流程**：
   - 设备连接MQTT Broker，使用设备SN作为Client ID
   - 设备订阅主题：device/down/{设备SN}
   - 设备发布上线消息到主题：device/up/{设备SN}
   - 通信服务订阅所有device/up/#主题，接收设备上报消息

2. **服务端下发命令流程**：
   - 设备服务根据设备SN选择合适的通信服务
   - 通信服务发布命令到主题：device/down/{设备SN}
   - 设备接收命令并执行
   - 设备发布执行结果到主题：device/up/{设备SN}

#### 1.2.5 连接管理策略
- **连接认证**：使用设备SN和预设密钥进行认证
- **遗嘱消息**：设备设置遗嘱消息，连接断开时自动发布到device/up/{设备SN}主题
- **会话保持**：设备设置cleanSession=false，确保离线消息不丢失
- **连接监控**：通信服务定期检查设备连接状态，超过300秒未活跃则标记为离线

## 2. 开发环境与技术栈选型

### 2.1 编程语言、开发工具及相关依赖库
| 类别 | 技术栈 | 版本 | 用途 |
|------|--------|------|------|
| 编程语言 | Java | 1.8+ | 后端服务开发 |
| 开发框架 | Spring Boot | 2.3.12.RELEASE | 微服务框架 |
| 开发框架 | Netty | 4.1.73.Final | TCP长连接通信 |
| MQTT客户端 | Eclipse Paho | 1.2.5 | 设备端MQTT实现 |
| MQTT Broker | EMQ X | 4.3.10 | MQTT消息中间件 |
| 缓存 | Redis | 6.2.5 | 设备连接映射、会话管理 |
| 消息队列 | RocketMQ | 4.9.1 | 设备消息异步处理 |
| 开发工具 | IntelliJ IDEA | 2021.3 | 代码开发与调试 |
| 容器化 | Docker | 20.10.11 | 开发环境部署 |

### 2.2 测试环境搭建方案

#### 2.2.1 模拟硬件设备
- **TCP设备模拟器**：
  - 基于Netty开发设备模拟器，支持多设备并发模拟
  - 模拟设备SN、设备类型、命令发送与接收
  - 支持断线重连、心跳发送等功能

- **MQTT设备模拟器**：
  - 基于Eclipse Paho开发MQTT设备模拟器
  - 支持多设备并发连接，模拟不同QoS级别的消息发布/订阅
  - 支持遗嘱消息、会话保持等功能

#### 2.2.2 网络环境配置
- **局域网测试**：搭建本地测试环境，模拟设备与服务端在同一局域网内通信
- **广域网测试**：使用网络延迟模拟器，模拟不同网络环境下的通信情况
- **高并发测试**：使用JMeter或自定义压测工具，模拟1000+设备并发连接

## 3. 功能模块划分与开发任务分配

### 3.1 通信模块核心功能点

#### 3.1.1 Netty TCP通信模块
| 功能点 | 描述 |
|--------|------|
| 连接管理 | 设备连接的建立、维护、断开处理 |
| 消息编解码 | 自定义协议的编码与解码 |
| 命令处理 | 不同命令类型的业务逻辑处理 |
| 心跳检测 | 设备心跳的发送与接收处理 |
| 设备映射 | 设备SN到TCP连接的映射管理 |
| 异常处理 | 各种异常情况的处理与恢复 |

#### 3.1.2 MQTT通信模块
| 功能点 | 描述 |
|--------|------|
| 连接管理 | 设备MQTT连接的建立、维护、断开处理 |
| 主题管理 | 消息主题的创建、订阅、发布管理 |
| 消息处理 | MQTT消息的接收、解析与转发 |
| QoS保证 | 不同QoS级别的消息可靠传输 |
| 遗嘱消息处理 | 设备离线时的遗嘱消息处理 |
| 会话管理 | 设备会话状态的保存与恢复 |

### 3.2 模拟硬件端与软件服务端的实现范围

| 模块 | 实现范围 | 负责人 |
|------|----------|--------|
| Netty TCP服务端 | 连接管理、消息编解码、命令处理、心跳检测、设备映射 | 开发A |
| MQTT通信服务端 | 连接管理、主题管理、消息处理、QoS保证、遗嘱消息处理 | 开发B |
| 设备服务集成 | 与设备服务的接口集成，设备命令的下发与结果处理 | 开发C |
| TCP设备模拟器 | 多设备并发模拟、命令发送与接收、断线重连、心跳发送 | 开发D |
| MQTT设备模拟器 | 多设备并发连接、消息发布/订阅、遗嘱消息、会话保持 | 开发D |

### 3.3 各模块的开发优先级与时间预估

| 模块 | 优先级 | 时间预估 |
|------|--------|----------|
| Netty TCP服务端 | P0 | 15天 |
| MQTT通信服务端 | P0 | 15天 |
| TCP设备模拟器 | P1 | 7天 |
| MQTT设备模拟器 | P1 | 7天 |
| 设备服务集成 | P0 | 10天 |
| 测试与调试 | P0 | 10天 |

## 4. 测试策略与验收标准

### 4.1 单元测试、集成测试及系统测试的具体方案

#### 4.1.1 单元测试
- **测试框架**：JUnit 5 + Mockito
- **测试范围**：
  - 协议编解码器：测试各种协议格式的编码和解码
  - 命令处理器：测试各种命令的业务逻辑
  - 连接管理器：测试连接的建立、维护和断开

#### 4.1.2 集成测试
- **测试工具**：TestNG + Spring Boot Test
- **测试范围**：
  - Netty TCP服务与设备服务的集成
  - MQTT通信服务与设备服务的集成
  - Redis设备映射的正确性
  - RocketMQ消息队列的集成

#### 4.1.3 系统测试
- **测试工具**：JMeter + 自定义设备模拟器
- **测试场景**：
  - 设备正常上线、下发命令、执行结果返回
  - 设备异常断开后的重连机制
  - 高并发场景下的稳定性
  - 网络延迟情况下的通信可靠性

### 4.2 性能测试指标

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 最大并发连接数 | 10000+ | 使用设备模拟器进行压测 |
| 消息吞吐量 | 10000条/秒 | 使用JMeter进行消息发送测试 |
| 消息延迟 | <100ms | 测试消息从发送到接收的时间差 |
| 连接建立时间 | <500ms | 测试设备连接到服务端的时间 |
| 断线重连时间 | <3秒 | 测试设备断开后重连的时间 |

### 4.3 功能验证要点与验收通过标准

| 功能点 | 验证要点 | 验收标准 |
|--------|----------|----------|
| TCP连接管理 | 设备连接的建立、维护、断开 | 100%成功建立连接，断开后正确重连 |
| MQTT连接管理 | 设备MQTT连接的建立、维护、断开 | 100%成功连接，遗嘱消息正确触发 |
| 命令下发与执行 | 开柜、关柜、心跳等命令 | 命令执行成功率100%，结果返回正确 |
| 设备状态管理 | 设备在线/离线状态更新 | 设备状态更新及时，准确率100% |
| 异常处理 | 网络异常、设备异常等情况 | 系统稳定运行，无崩溃，异常恢复及时 |

## 5. 风险评估与应对措施

### 5.1 可能面临的技术难点及解决方案

| 技术难点 | 解决方案 |
|----------|----------|
| 高并发连接管理 | 优化Netty线程模型，调整backlog参数，使用连接池管理 |
| 消息丢失问题 | 使用RocketMQ保证消息可靠性，MQTT QoS 2级别保证消息只传递一次 |
| 设备重连风暴 | 实现指数退避重连机制，限制单位时间内的重连次数 |
| 协议兼容性 | 设计可扩展的协议格式，支持版本升级 |
| 网络延迟影响 | 实现超时重试机制，区分网络延迟和设备故障 |

### 5.2 两种通信方式的优缺点对比分析

| 对比维度 | Netty TCP长连接 | MQTT物联网协议 |
|----------|-----------------|----------------|
| 连接类型 | 长连接 | 长连接 |
| 消息格式 | 自定义二进制协议 | 标准MQTT协议 |
| 消息可靠性 | 需自行实现 | 内置QoS机制 |
| 设备管理 | 需自行实现 | 可借助MQTT Broker |
| 开发复杂度 | 较高 | 较低 |
| 扩展性 | 较好 | 优秀 |
| 网络适应性 | 一般 | 优秀，支持低带宽、高延迟网络 |
| 设备兼容性 | 需设备端支持自定义协议 | 广泛支持，设备端SDK丰富 |
| 适合场景 | 对实时性要求高的场景，如开柜命令 | 设备数量多、网络条件复杂的场景 |

## 6. 部署与运维方案

### 6.1 部署架构
- **TCP通信服务**：多节点部署，使用Nginx或LVS进行负载均衡
- **MQTT Broker**：集群部署，3节点，支持故障转移
- **设备服务**：微服务架构，部署在Kubernetes集群中

### 6.2 监控与告警
- **监控指标**：
  - 设备连接数、消息吞吐量、消息延迟
  - 服务CPU、内存、网络使用率
  - 错误率、重连率

- **告警机制**：
  - 设备离线超过阈值触发告警
  - 消息延迟超过阈值触发告警
  - 服务异常崩溃触发告警

## 7. 总结

本开发计划详细设计了智能货柜项目的两种通信方式：基于Netty的自定义TCP长连接协议和MQTT物联网通信协议。通过合理的技术架构设计、开发任务分配和测试策略，确保两种通信方式能够满足智能货柜项目的需求，支持大规模设备连接和高可靠通信。

在实际开发过程中，将根据项目进展情况和实际需求，对计划进行适当调整和优化，确保项目能够按时、高质量完成。